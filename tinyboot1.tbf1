( Second step toward a tiny bootstrap Forth compiler written in itself.

Generates an ELF executable for x86 Linux that exits with return code
42, following Brian Raiter’s lead.  Uses functions.

Compile-time primitives:
( — defines a comment that extends to the next right-paren
v — defines a dataspace label, like for a variable.
b — compiles a literal byte, numerically, into data space.
# — compiles a literal four-byte little-endian number into data space.
^ — the location where the program should start executing [everything else
    is just definitions]
space, newline — ignored
: — defines a function
[ — begins a conditional block, which consumes the value on top of the stack
    and is skipped if that value is zero
] — ends a conditional block, matching the latest unmatched [
{ — begins a loop
} — ends a loop — consumes the value on top of the stack and loops back to 
    the matching { if it is nonzero

Run-time primitives:
G — gets a byte from stdin
W — given an address and size on the stack, writes the specified number of 
    bytes to stdout
Q — exits the program with a return code of 0
+ — adds two numbers
@ — fetches a word from memory
! — stores to a word in memory whose address is on top of the stack
~ — bitwise-negates a word
; — returns from a function
< — a less-than test
m — not used directly since the interpreter doesn't implement it,
    this invokes an arbitrary system call with up to three arguments.
    The compiler's implementations of G, W, and Q use this.
s — stores to a byte in memory whose address is on top of the stack

Defined in this file, all necessarily run-time:
h — the ELF header
e — the location of the entry point word in the ELF header
o — the location of the word in the ELF program header that specifies the .ORG
S — the location of the word in the ELF program header that specifies filesize
$ — the start of the area where the program gets compiled
- — subtraction
` — the end of the headers
Z — the end of the predefined blob of bytes to output, with slight changes
H — the point where the program is currently getting compiled
X, Y — two temporary variables
d — DUP
p — DROP
x — SWAP
= — an equality test
> — a greater-than test
D — dispatch a byte being compiled
R — compile the sequence `xchg %ebp, %esp`, buffered by a peephole optimizer
. — add a byte to the program being compiled, flushing the peephole buffer
u — add a byte to the program being compiled, used to implement the peephole 
    buffer
U — the peephole buffer itself, a boolean storing whether there’s a pending 
    `xchg %ebp, %esp`
T — table of types of definitions
A — table of addresses of definitions
F — 4 *
C — register a Colon definition in the tables
V — register a Variable definition in the tables
a — translate an address from compiler address space to user address space
& — compile a byte if it's a colon or variable definition
O — boolean OR
N — boolean NOT
w — like G, but skips whitespace
B — a buffer for w
E — stick the item on top of the stack at H as four bytes, advancing H by 4
L — compile code to push the constant on the compile-time stack
t — one step in base-ten decoding: x <- 10x + y
n — parse a number from input and push it on the compile-time stack
J — compile a forward conditional jump [
P — resolve a forward conditional jump ]
j — compile a backwards negative conditional jump }
M — the location in the compiler's memory for the system call routine

Directory of magic numbers used, other than 0 and 1:
2 — as e_type, means ET_EXEC, an executable file;
    in the T table, means that a user-defined word is a “variable”
3 — as e_machine, means EM_386, Intel 80386;
    the system call number of the `read` system call
4 — the size of a 32-bit word;
    second byte of `sub [%esp], %eax`;
    the system call number of the `write` system call
7 — in p_flags, means PF_R | PF_W | PF_X, making the program memory readable, 
    writable, and executable; 
    in random bytes, is the pop %es instruction, which is used to help
    disassemblers resync with the instruction stream
8 — second byte of `movb %cl, [%eax]`;
    2048 / 256
10 — '\n' the ASCII linefeed or newline character
15 — 0F extended opcode prefix byte, used to introduce `setle`, `movsbl`, 
     and `movzbl` instructions, as well as others not used here.
32 — the size of the ELF program header;
     ' ' ASCII space character
33 — '!' ASCII exclamation mark character
35 — '#' ASCII number sign character
36 — third byte of `sub [%esp], %eax`
40 — the size of any ELF segment headers that might exist;
     '(' ASCII left parenthesis
41 — ASCII right parenthesis
42 — '*' ASCII asterisk
43 — first byte of `sub [%esp], %eax`;
     '+' ASCII plus
48 — '0' ASCII zero
52 — the size of the ELF header
57 — '9' ASCII nine
58 — ':' ASCII colon
59 — ';' ASCII semicolon
60 — '<' ASCII less-than
64 — '@' ASCII at-sign
69 — 'E' ASCII uppercase E
70 — 'F' ASCII uppercase F
71 — 'G' ASCII uppercase G
76 — 'L' ASCII uppercase L
80 — `push %eax`
81 — 'Q' ASCII uppercase Q
87 — 'W' ASCII uppercase W
88 — `pop %eax`
89 — `pop %ecx`
90 — `pop %edx`
91 — `pop %ebx`;
     '[' ASCII left square bracket
92 — '\' ASCII backslash
93 — ']' ASCII right square bracket
98 — 'b' ASCII lowercase B
109 — 'm' ASCII lowercase M
115 — 's' ASCII lowercase S
116 — `jz` instruction, one-byte immediate PC-relative destination
117 — `jnz` instruction, likewise
118 — 'v' ASCII lowercase V
123 — '{' ASCII left curly brace
125 — '}' ASCII right curly brace
126 — '~' ASCII tilde
127 — the first byte of an ELF executable
128 — the interrupt number Linux uses for system calls: 0x80
129 — first byte of `sub $xxx, %ebp`
133 — first byte of `test %eax, %eax`
135 — first byte of `xchg %ebp, %esp`
136 — first byte of `movb %cl, [%eax]`
137 — first byte of `mov %esp, %ebp`
139 — first byte of `mov [%eax], %eax`, followed by 0
143 — first byte of `pop [%eax]`, followed by 0
158 — second byte of `setle %al`
184 — `mov $xxx, %eax` — load immediate %eax
192 — second byte of `test %eax, %eax`;
      third byte of `setle %al`;
      third byte of `movsbl %al, %eax`
195 — `ret` instruction
200 — second byte of `dec %al` and `add %ecx, %eax`
205 — `int` interrupt instruction
208 — second byte of `not %eax`
229 — second byte of `mov %esp, %ebp`
232 — `call` instruction opcode, 4-byte immediate PC-relative destination
236 — second byte of `xchg %ebp, %esp`
237 — second byte of `sub $xxx, %ebp`
247 — first byte of `not %eax`
254 — first byte of `dec %al`
1024 — a table size in bytes: 256 entries of 4 bytes each
4096 — the program runs with its origin at 4096, 0x1000, because that still 
       leaves hex addresses easy to type and read, while leaving it likely 
       that null pointer references will crash the program rather than making
       mysterious bugs.  Also there’s a buffer of this size, which will go 
       away soon.
655360 — the total memory space allocated for the program
)

v h ( ELF header, Elf32_Ehdr )
( ELF info from http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html)
( but I'm using 4096 for my origin rather than 0x08048000)
    ( e_ident:) b 127 b 69 ( E) b 76 ( L) b 70 ( F) b 1 b 1 b 1
                b 0 b 0 b 0  b 0 b 0 b 0  b 0 b 0 b 0 ( 9 bytes of padding)
     ( e_type:) b 2 b 0   ( e_machine:) b 3 b 0
  ( e_version:) # 1         ( e_entry:) v e # 0
               ( The program header offset is 52, the same as the header size,
                  since the program header immediately follows this ELF header )
    ( e_phoff:) # 52        ( e_shoff:) # 0
    ( e_flags:) # 0        ( e_ehsize:) b 52 b 0 
( e_phentsize:) b 32 b 0    ( e_phnum:) b 1 b 0 
( e_shentsize:) b 40 b 0 ( e_shentnum:) b 0 b 0
 ( e_shstrndx:) b 0 b 0 

( program header, Elf32_Phdr; note that we are now 52 bytes from 'h' )
      ( p_type:) # 1       ( p_offset:) # 0 
     ( p_vaddr:) v o # 4096 ( p_paddr:) # 0 ( should be 0, not org as Brian has)
( Note that you can only make p_memsz as large as you want if p_flags has a 
  2 = PF_W in it.  Otherwise, even one extra byte results in a segfault. )
    ( p_filesz:) v S # 0    ( p_memsz:) # 655360 ( should be enough for anyone)
     ( p_flags:) # 7        ( p_align:) # 4096

v `
b 7 b 7 b 7 b 7 b 7 ( to help disassemblers resync )
v M  ( system call routine; called in program with lowercase `m`)
  ( syscall number already in %eax )
( xchg %ebp, %esp) b 135 b 236
( this really weird order is basically a special case for write(2)
( first we pop the first argument, then the third, then the second)
       ( pop %ebx) b 91
       ( pop %edx) b 90
       ( pop %ecx) b 89
       ( int 0x80) b 205 b 128
( xchg %ebp, %esp) b 135 b 236
            ( ret) b 195
v / b 0 ( a one-byte read buffer for the program being compiled )
( okay, so let's do two writes.
The first write will write out the stuff that's static, i.e. not
generated by the compiler: all the stuff above.
The second write will write out the stuff that's the compiler uses H to write,
starting from `$`.
Then the only slightly hairy thing is to adjust `m` and `\` 
to point to the right place: a bit before `$`. )
v Z ( the end of the non-compiled stuff. )
( so the correct adjustment is to add $ - Z to them.
)

: $ h 8192 + ;  ( this is where the program gets compiled )
( hopefully 8192 is enough to skip over the compiler itself )

v H # 0 ( "HERE", where we're compiling )

v X # 0  v Y # 0  ( temp vars )
: d  X !  X @  X @ ; ( DUP )  : p X ! ; ( DROP/pop )  
: x X ! Y ! X @ Y @ ; ( SWAP/exch )

: -  ~ 1 +  + ; ( take two's complement, then add, to subtract )
: N [ 0 ; ] 1 ; ( Boolean negation ) : = - N ; ( equality )
: O [ p 1 ; ] ; ( Boolean OR )       : > x < ; ( greater-than )

( routine to add a byte to the program being compiled )
: u H @ s  H @ 1 + H ! ;
( R emits an `xchg %ebp, %esp` — but we buffer it to see if it’s canceled by 
  another one before actually emitting it. U is the buffer, and % flushes it.
  So . adds a byte to the program being compiled, after flushing this buffer. )
v U # 0  : % U @ [ 135 u 236 u  0 U ! ] ;  : R U @ N U ! ;  : . % u ;

v T * 1024 ( Table of Types of definitions: 1 for subroutine, 2 for data label )
v A * 1024 ( table of Addresses of definitions )
: F d + d + ; ( 4 *, for indexing these tables )
: C % d F T + 1 x !  H @ x F A + ! ; ( register a colon definition )
: V % d F T + 2 x !  H @ x F A + ! ; ( register a variable definition )
v B # 0 ( buffer for w )
: w { G B !  B @ 32 = B @ 10 = O N [ B @ ; ]  1 }  ( return next non-whitespace char )
: E % H @ ! H @ 4 + H ! ; ( store word on top of stack at H, praise non-aligned access )
: I d 48 <  x 57 >  O N ; ( isdigit )
: L 80 . ( push %eax ) 184 . ( load immediate %eax ) E ; ( push a literal )
: t x d F + d +  + ; ( for base-10 decoding: A B -> 10A + B )
: n { G d I N [ p ; ] 48 - t 1 }  ( parse a number from successive digits )
( NOTE: n eats the next byte after the end of the number and discards it. )

: a  $ - Z h - + o @ + ;  ( convert from compiler address space to user space )

( routine to compile bytes found in the table )
: & d F T + @ 1 = [ ( if it’s a subroutine...)
    R 232 . ( CALL instruction; now we have to compute the offset )
    H @ 4 + ( find address of next instruction )
    x F A + @ x - ( find offset to subroutine )
    E ( encode it )
    R ; ] ( okay, and otherwise, it’s a variable... )
  F A + @ a L ;

( J: compile a forward conditional jump )
: J 133 . 192 . ( test %eax, %eax ) 88 . ( pop %eax ) 116 . H @ 0 . ( jz 0 ) ;
( j: compile a backward conditional jump )
: j 133 . 192 . 88 . 117 . H @ - 1 - . ( jnz whatever ) ;
( P: resolve a forward conditional jump by backpatching )
( 1 - is needed because the saved address is one byte inside the jnz 
  instruction, but the offset should be calculated from the beginning of the 
  next instruction )
: P  d % H @ x - 1 -  x s ;  

( implementation of < )
: i 43 . 4 . 36 . ( sub [%esp], %eax )   88 . ( pop %eax ) 
    15 . 158 . 192 . ( setle %al )       254 . 200 . ( dec %al )
    15 . 190 . 192 . ( movsbl %al, %eax ) ;

( routine to dispatch a byte being compiled )
: D 
  d 40 = [ p { G 41 - } ; ]   ( drop comments until right paren )
  d 32 = [ p ; ]              ( drop spaces )
  d 10 = [ p ; ]              ( drop newlines )
  d 35 = [ p w 48 - n E ; ]   ( # writes the next number as data literally )
  d 98 = [ p w 48 - n . ; ]   ( b does the same, but just as one byte )
  d 59 = [ p R 195 . ; ]      ( ; is R, then `ret` )
  d 33 = [ p 143 . 0 . 88 . ; ] ( ! is `pop [%eax]; pop %eax` )
  d 64 = [ p 139 . 0 . ; ]      ( @ is `mov [%eax], %eax` )
  d 58 = [ p w C R ; ]        ( : registers the next non-blank as a colon 
                                  definition, then compiles a procedure prolog )
  d 91 = [ p J ; ]            ( [ compiles a conditional jump, pushing an 
                                  address for backpatching )
  d 93 = [ p P ; ]            ( ] backpatches the address on the compile stack )
  d 123 = [ p % H @ ; ]       ( { merely pushes an address to jump back to )
  d 125 = [ p j ; ]           ( } compiles a conditional jump to that address )
  d 118 = [ p w V ; ]         ( v registers the next non-blank as a 
                                  variable label )
  d 43 = [ p 89 . 1 . 200 . ; ] ( + is `pop %ecx; add %ecx, %eax` )
  d 126 = [ p 247 . 208 . ; ] ( ~ is `not %eax` )
  d 115 = [ p 89 . 136 . 8 . 88 . ; ] ( s is `pop %ecx; movb %cl, [%eax]; 
                                              pop %eax` )
  d 60 = [ p i ; ]              ( < is implemented in “i” )
  d F T + @ [ & ; ]           ( if it’s in the table, dispatch to & )
  d I [ 48 - n L ; ]          ( if it’s a digit, parse a number, compile code
                                to push that number immediate )
  d 42 = [ p w 48 - n         ( * reads a number )
           H @ + H ! ; ]      ( and increments H by that number )
  d 81 = [ p 0 L 0 L 0 L      ( Q calls _exit(0, 0, 0)
             1 L 109 & ; ]    ( system call #1 (__NR_exit) ( syscall is `m` )
  d 87 = [ p 1 L 4 L 109 &    ( W calls write(1, x, y) ( syscall #4 ) 
           88 . ; ]           ( pop %eax to discard result )
  d 94 = [ p H @ a e !        ( ^ sets the entry point e, a virtual address )
        137 . 229 .           ( mov %esp, %ebp to initialize %ebp to %esp-2048 )
        129 . 237 . 0 . 8 . 0 . 0 . ; ] ( sub $2048, %ebp XXX use 2048 E? )
  . ;                     ( default is to copy to output )
: K ( routine to "kompile" input to output )
  { G d 0 1 - = [ p ; ] ( return if char is -1 )
    D 1 }

^ 
M $ Z - + H ! 109 C  ( register `m` routine for system calls using dummy `H` )
/ $ Z - + H ! 92 V   ( register `\` variable )
$ H ! ( initialize H )
( routine for `G` — wow, this is awful! compiles to about 80 bytes )
7 . 7 . 7 . 7 . 7 .  ( help disassemblers resync with the instruction stream )
71 C R
92 D 1 L 0 L 3 L 109 D ( \ 1 0 3 m → syscall(__NR_read=3, 0, \, 1)
1 L 60 D 91 D ( 1 < [ → if it’s less than 1 )
  88 . 0 1 - L 59 D  ( then pop %eax and return -1 )
93 D ( ] → otherwise, )
92 D ( get the address of \ )
15 . 182 . 0 . ( and fetch a byte from it: `movzbl [%eax], %eax` )
59 D ( and return! )

K ( compile input into output )
( now H - $ is the size of the compiled part of the program
  and Z - h is the size of the fixed-format part. )
H @  $ -  Z h - +  S ! ( store total size in S )
h   Z h - W ( write headers )
$ H @ $ - W ( write compiled part of program )
Q
