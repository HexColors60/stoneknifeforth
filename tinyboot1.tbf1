( Second step toward a tiny bootstrap Forth compiler written in itself.

Generates an ELF executable for x86 Linux that exits with return code
42, following Brian Raiter’s lead.  Uses functions.

Compile-time primitives:
( — defines a comment that extends to the next right-paren
v — defines a dataspace label, like for a variable.
b — compiles a literal byte, numerically, into data space.
# — compiles a literal four-byte little-endian number into data space.
^ — the location where the program should start executing [everything else
    is just definitions]
space, newline — ignored
: — defines a function

Run-time primitives:
W — given an address and size on the stack, writes the specified number of 
    bytes to stdout
Q — exits the program with a return code of 0
+ — adds two numbers
@ — fetches a word from memory
! — stores to a word in memory
~ — bitwise-negates a word
; — returns from a function
< — a less-than test

Defined in this file, all necessarily run-time:
h — the ELF header
e — the location of the entry point word in the ELF header
o — the location of the word in the ELF program header that specifies the .ORG
S — the location of the word in the ELF program header that specifies filesize
$ — the start of the area where the program gets compiled
- — subtraction
` — the end of the headers
H — the point where the program is currently getting compiled
X, Y, Z — three temporary variables
d — DUP
p — DROP
x — SWAP
= — an equality test
> — a greater-than test
D — dispatch a byte being compiled
R — compile the sequence `xchg %ebp, %esp`, buffered by a peephole optimizer
. — add a byte to the program being compiled, flushing the peephole buffer
u — add a byte to the program being compiled, used to implement the peephole 
    buffer
U — the peephole buffer itself, a boolean storing whether there’s a pending 
    `xchg %ebp, %esp`
T — table of types of definitions
A — table of addresses of definitions
F — 4 *
C — register a Colon definition in the tables
V — register a Variable definition in the tables
& — compile a byte if it's a colon or variable definition
O — boolean OR
N — boolean NOT
w — like G, but skips whitespace
B — a buffer for w
E — stick the item on top of the stack at H as four bytes, advancing H by 4
L — compile code to push the constant on the compile-time stack
t — one step in base-ten decoding: x <- 10x + y
n — parse a number from input and push it on the compile-time stack
J — compile a forward conditional jump [
P — resolve a forward conditional jump ]
j — compile a backwards negative conditional jump }
)

v h ( ELF header, Elf32_Ehdr )
( ELF info from http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html)
( but I'm using 4096 for my origin rather than 0x08048000)
    ( e_ident:) b 127 b 69 ( E) b 76 ( L) b 70 ( F) b 1 b 1 b 1
                b 0 b 0 b 0  b 0 b 0 b 0  b 0 b 0 b 0 ( 9 bytes of padding)
     ( e_type:) b 2 b 0   ( e_machine:) b 3 b 0
  ( e_version:) # 1         ( e_entry:) v e # 0
               ( The program header offset is 52, the same as the header size,
                  since the program header immediately follows this ELF header )
    ( e_phoff:) # 52        ( e_shoff:) # 0
    ( e_flags:) # 0        ( e_ehsize:) b 52 b 0 
( e_phentsize:) b 32 b 0    ( e_phnum:) b 1 b 0 
( e_shentsize:) b 40 b 0 ( e_shentnum:) b 0 b 0
 ( e_shstrndx:) b 0 b 0 

( program header, Elf32_Phdr; note that we are now 52 bytes from 'h' )
      ( p_type:) # 1       ( p_offset:) # 0 
     ( p_vaddr:) v o # 4096 ( p_paddr:) # 0 ( should be 0, not org as Brian has)
( Note that you can only make p_memsz as large as you want if p_flags has a 
  2 = PF_W in it.  Otherwise, even one extra byte results in a segfault. )
    ( p_filesz:) v S # 0    ( p_memsz:) # 655360 ( should be enough for anyone)
     ( p_flags:) # 7        ( p_align:) # 4096

v `
( mov bl, 42) b 179 b 42
   ( inc eax) b 64
  ( int 0x80) b 205 b 128
v $ * 4096 ( 4096 bytes should be plenty for ANY program! ☺ )
( this space for compiling the program eventually has to move to the end of 
  everything, so it can expand.  something like : $ h 8192 + ; )

v H # 0 ( "HERE", where we're compiling )

v X # 0  v Y # 0  v Z # 0 ( temp vars )
: d  X !  X @  X @ ; ( DUP )  : p X ! ; ( DROP/pop )  
: x X ! Y ! X @ Y @ ; ( SWAP/exch )

: -  ~ 1 +  + ; ( take two's complement, then add, to subtract )
: N [ 0 ; ] 1 ; ( Boolean negation ) : = - N ; ( equality )
: O [ p 1 ; ] ; ( Boolean OR )       : > x < ; ( greater-than )

( routine to add a byte to the program being compiled )
: u H @ s  H @ 1 + H ! ;
( R emits an `xchg %ebp, %esp` — but we buffer it to see if it’s canceled by 
  another one before actually emitting it. U is the buffer, and % flushes it.
  So . adds a byte to the program being compiled, after flushing this buffer. )
v U # 0  : % U @ [ 135 u 236 u  0 U ! ] ;  : R U @ N U ! ;  : . % u ;

v T * 1024 ( Table of Types of definitions: 1 for subroutine, 2 for data label )
v A * 1024 ( table of Addresses of definitions )
: F d + d + ; ( 4 *, for indexing these tables )
: C % d F T + 1 x !  H @ x F A + ! ; ( register a colon definition )
: V % d F T + 2 x !  H @ x F A + ! ; ( register a variable definition )
v B # 0 ( buffer for w )
: w { G B !  B @ 32 = B @ 10 = O N [ B @ ; ]  1 }  ( return next non-whitespace char )
: E % H @ ! H @ 4 + H ! ; ( store word on top of stack at H, praise non-aligned access )
: I d 48 <  x 57 >  O N ; ( isdigit )
: L 80 . ( push %eax ) 184 . ( load immediate %eax ) E ; ( push a literal )
: t x d F + d +  + ; ( for base-10 decoding: A B -> 10A + B )
: n { G d I N [ p ; ] 48 - t 1 }  ( parse a number from successive digits )
( NOTE: n eats the next byte after the end of the number and discards it. )


( routine to compile bytes found in the table )
: & d F T + @ 1 = [ ( if it’s a subroutine...)
    R 232 . ( CALL instruction; now we have to compute the offset )
    H @ 4 + ( find address of next instruction )
    x F A + @ x - ( find offset to subroutine )
    E ( encode it )
    R ; ] ( okay, and otherwise, it’s a variable... )
  F A + @ h - o @ + L ;

( J: compile a forward conditional jump )
: J 133 . 192 . ( test %eax, %eax ) 88 . ( pop %eax ) 117 . H @ 0 . ( jnz 0 ) ;
( j: compile a backward conditional jump )
: j 133 . 192 . 88 . 117 . H @ - 1 - . ( jnz whatever ) ;
( P: resolve a forward conditional jump by backpatching )
( 1 - is needed because the saved address is one byte inside the jnz 
  instruction, but the offset should be calculated from the beginning of the 
  next instruction )
: P  d % H @ x - 1 -  x s ;  

( implementation of <.  I hope this is < and not >. )
: i 43 . 4 . 36 . ( sub [%esp], %eax )   88 . 88 . ( pop %eax twice ) 
    15 . 157 . 192 . ( setge %al )       254 . 200 . ( dec %al )
    15 . 190 . 192 . ( movsbl %al, %eax ) ;

( routine to dispatch a byte being compiled )
: D 
  d 40 = [ { G 41 - } ; ]     ( drop comments until right paren )
  d 32 = [ p ; ]              ( drop spaces )
  d 10 = [ p ; ]              ( drop newlines )
  d 35 = [ p w 48 - n E ; ]   ( # writes the next number as data literally )
  d 98 = [ p w 48 - n . ; ]   ( b does the same, but just as one byte )
  d 59 = [ p R 195 . ; ]      ( ; is R, then `ret` )
  d 33 = [ p 143 . 0 . 88 . ; ] ( ! is `pop [%eax]; pop %eax` )
  d 64 = [ p 139 . 0 . ; ]      ( @ is `mov [%eax], %eax` )
  d 58 = [ p w C R ; ]        ( : registers the next non-blank as a colon 
                                  definition, then compiles a procedure prolog )
  d 91 = [ p J ; ]            ( [ compiles a conditional jump, pushing an 
                                  address for backpatching )
  d 93 = [ p P ; ]            ( ] backpatches the address on the compile stack )
  d 123 = [ p H @ ; ]         ( { merely pushes an address to jump back to )
  d 125 = [ p j ; ]           ( } compiles a conditional jump to that address )
  d 118 = [ p w V ; ]         ( v registers the next non-blank as a 
                                  variable label )
  d 43 = [ p 89 . 1 . 200 . ; ] ( + is `pop %ecx; add %ecx, %eax` )
  d 126 = [ p 247 . 208 . ; ] ( ~ is `not %eax` )
  d 115 = [ p 89 . 136 . 8 . 88 . ; ] ( s is `pop %ecx; movb %cl, [%eax]; 
                                              pop %eax` )
  d 60 = [ p i ; ]              ( < is implemented in “i” )
  d F T + @ [ & ; ]           ( if it’s in the table, dispatch to & )
  d I [ 48 - n L ; ]          ( if it’s a digit, parse a number, compile code
                                to push that number immediate )
  . ;                     ( default is to copy to output )
: K ( routine to "kompile" input to output )
  { G d 0 1 - = [ p ; ] ( return if char is -1 )
    D 1 }

^ ` h - o @ + e ! ( set entry point correctly wrt origin )
$ H ! ( initialize H )
K ( copy input into output )
H @  h -  S ! ( subtract h from H to get size of whole program )
h S @ W Q
